### Pointer를 왜 사용하는가?

DS021번 문제 관련
### int arr1[]와 int* arr를 파라미터로 넘겨줄 때 둘은 어떤 차이가 있을까?
* 클래스 멤버 함수에서 파라미터로 int arr[]를 쓰든, int* arr를 쓰든 똑같이 포인터로 동작함. -> 기본 스타일(배열처럼 보이게 할지, 포인터처럼 보이게 할지)은 자유지만, 기능적으로는 같다.
* 하지만 파라미터 말고 클래스의 멤버 변수로 배열을 선언할 때는 진짜 차이가 있음.

| 항목             | `int arr1[10]`                        | `int* arr2`                                      |
|------------------|----------------------------------------|--------------------------------------------------|
| 메모리 공간      | 클래스 안에 10개 `int` 저장            | 포인터 1개만 저장                                |
| 초기화           | `arr1`은 자동으로 메모리 확보           | `arr2`는 따로 `new` 또는 외부 배열 할당 필요     |
| 크기 정보 보존   | ✅ (`sizeof(arr1)`은 배열 전체 크기)    | ❌ (`sizeof(arr2)`는 포인터 크기만 나옴)          |

* 그렇다면 더 안전하고 명확한 방법은?

| 상황                 | 추천 방식                                  |
|----------------------|---------------------------------------------|
| 간단한 C 스타일 코드 | `int* arr` 또는 `int arr[]`                 |
| 현대 C++ / 안전성 중요 | `std::span<int>` (C++20 이상), `std::vector<int>&`, `std::array<int, N>&` | ->나중에 따로 공부할 것

DS022번 문제 관련
class를 포인터 타입으로 선언하면 포인터 타입으로 선언하지 않았을 때보다 좋은 점이 무엇인가?

## 포인터(또는 참조)를 쓰면 좋은 점들
장점 1. 복사 비용 절약
장점 2. 원본 수정 가능
장점 3. 다형성 (Polymorphism) -> 포인터나 참조로 전달하면 상속 + 가상함수 조합으로 동적 바인딩 가능!
참고: 포인터는 null체크 시, 참조는 null 불필요시 사용함.
# null체크란?
# 상속 가상함수와 동적 바인딩이란??


DS023번 문제에서, class를 포인터 타입 배열로 선언하였다. 왜 굳이 포인터를 사용해야 하는 것일까?
->AI 답변 : 
1. 동적 할당 가능 (new 사용)
* 배열을 포인터로 선언하면 동적으로 크기를 지정할 수 있기 때문이에요.
* 크기가 고정된 배열(int arr[10];)은 컴파일 타임에 크기가 결정되지만, 포인터를 사용하면 런타임에 크기를 변경할 수 있어요.

2. 클래스 매서드에서 배열을 전달할 때 유연성 증가
* C++에서는 배열을 함수(메소드)에 전달할 때, 실제 배열의 크기 정보는 전달되지 않음.
* 포인터로 선언하면, 배열을 쉽게 다른 함수에 전달할 수 있고 유연하게 활용 가능.

ex)
void printArray(int* arr, int size) {  // 배열을 포인터로 받음
    for (int i = 0; i < size; i++)
        std::cout << arr[i] << " ";
}

* 배열을 쉽게 전달한다는 것:배열을 인자로 넘길 때 배열 전체가 복사되지 않고 주소를 전달할 수 있다는 점이에요.
즉, 배열을 함수에 전달할 때 포인터를 사용하면 메모리 효율성이 높아지고, 변경이 가능한 유연한 코드를 작성할 수 있어요.
✅ 배열의 주소만 전달되므로 복사 비용 없이 직접 참조 가능
✅ "int *arr"을 통해 원본 배열에 접근하여 수정 가능

* 포인터를 사용하지 않은 경우 (배열 복사 문제)
만약 포인터 없이 배열을 전달하면 배열 전체가 복사되어 불필요한 메모리 사용이 증가할 수 있어요.
✅ 배열을 복사하면 원본 값이 그대로 유지되지만, 불필요한 메모리 사용이 증가할 수 있음

📌 정리
✅ 포인터를 사용하면 배열의 주소만 전달 → 메모리 절약 & 효율적인 접근 가능
✅ 배열을 직접 수정 가능 → 값 변경이 함수 밖에서도 유지됨 ->여기서 "함수"란? class 내부에 있는 method도 포함함. 즉, **배열을 class.method에서 수정하려면 포인터 타입으로 선언해야 변경이 반영된다.**
✅ 배열 전체를 복사하지 않으므로 속도와 성능 향상
🚀 배열을 포인터 없이 전달하면, 원본이 수정되지 않음 → 값 복사 방식
🚀 포인터 타입으로 배열을 전달하면, 클래스 내부에서 직접 수정 가능(클래스 메서드가 원본 배열의 데이터를 변경할 수 있도록 메모리 주소를 직접 참조한다는 뜻)
🚀 객체 내부에서 배열을 동적으로 관리하고 싶다면 포인터 사용이 필수적
🚀 동적 관리란 객체 내부에서 메모리를 직접 할당하고 변경할 수 있도록 하는 것

3. 객체 내부에서 관리 하기 편리함

 * 인터를 사용하면 객체 내부에서 배열을 관리하면서 크기를 동적으로 조절 가능.
 * 객체를 복사할 때 **깊은 복사(deep copy)**를 할 수도 있어요.

 ##### 깊은 복사란? 
  새로운 메모리를 할당하고 데이터를 직접 복사하는 방식.
  원본 객체와 독립적인 메모리를 갖게 되므로 안전함.
  객체가 삭제되더라도 복사본이 독립적으로 존재하므로 메모리 오류가 발생하지 않음
  ✅ a는 새로운 메모리를 할당받고 데이터도 복사되므로 b와 독립적으로 존재함!
  ✅ 깊은 복사를 구현하면 메모리 공유 문제 없이 안전하게 객체를 관리할 수 있음.
  🚀 객체에 포인터가 포함되어 있을 때는 반드시 깊은 복사를 고려해야 해요!

 ##### 얕은 복사란(Shallow Copy)?
  기본적으로 객체의 멤버 변수를 그대로 복사하는 방식.
  포인터가 포함된 객체를 복사할 경우, 주소만 복사되므로 원본과 복사본이 같은 메모리를 공유하게 됨.
  원본 객체가 삭제되면, 복사본에서 참조하는 메모리도 해제되어 예기치 않은 오류(메모리 접근 오류)가 발생할 수 있음.
  * 문제점: 복사된 것과 원본은 같은 메모리 주소를 공유하고 있기 때문에, 원본이 삭제되면 영향을 받는다.(어떻게? delete로 지워지는 것인가?) 
  # 질문

📌 깊은 복사 vs 얕은 복사 차이 정리
| **구분**   | **얕은 복사 (Shallow Copy)** | **깊은 복사 (Deep Copy)** |
|----------|------------------|------------------|
| **복사 방식** | 원본 객체의 주소만 복사 | 새로운 메모리 할당 후 데이터 복사 |
| **메모리 공유** | 원본과 복사본이 같은 메모리 사용 | 독립적인 메모리 공간 확보 |
| **문제점** | 원본 객체 삭제 시 메모리 오류 발생 가능 | 원본 객체 삭제해도 안전함 |
| **사용 예시** | 기본 복사 (클래스 내 포인터 없는 경우) | 포인터를 포함한 클래스에서 추천됨 |

##### 정리

✅ 포인터 배열을 사용하면 동적으로 크기 변경 가능
✅ 클래스 메서드에서 배열을 쉽게 전달할 수 있음
✅ 객체 내부에서 배열을 관리하기 용이
✅ 깊은 복사 및 동적 메모리 관리 가능

gpt답변 : new라는 연산자를 사용하려면 그 객체의 포인터를 반환하기 때문에 포인터 타입으로 선언해야만 한다.
